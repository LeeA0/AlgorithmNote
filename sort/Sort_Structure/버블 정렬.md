### 2️⃣버블 정렬

> 바로 옆에 있는 값과 비교해서 더 작은 값을 앞으로 보내는 것을 반복하는 방법

![버블정렬 이미지 검색결과](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F275F9A4A545095BD01)

- 구현은 가장 쉽지만 가장 비효율적인 알고리즘

- 비교를 반복하며 가장 큰 값이 뒤로 이동하여 fix 된다

```java
//구현 시 이중 반복문을 사용하여 구현할 수 있음
int[] a = {5, 3, 8, 1, 2, 7};
for(int i=0; i<a.length; i++){
    for(int j=0; j<a.length-i-1; j++){ 
        if(a[j] > a[j+1]){ //왼쪽의 값이 오른쪽보다 크다면
            //swap
            int tmp = a[j];
            a[j] = a[j+1];
            a[j+1] = tmp;
        }
    }
}
```



#### 버블 정렬 :: 시간복잡도

---

- 선택정렬과 시간 복잡도는 같다

*O(N^2)*

- **BUT) ** 실제로 수행했을 때 선택 정렬보다 느리게 작동

  > why? 자리를 바꾸는 연산 작업을 선택정렬보다 월등히 많이 수행함 
  >
  > 따라서 컴퓨터 내부적인 연산이 가장 비효율적으로 일어나고 
  >
  > 실제 수행시간이 정렬 알고리즘 중 가장 느린 알고리즘

